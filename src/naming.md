# Именование

_Дать имя и не остаться в дураках_

Пожалуй самое сложное в программировании - это доносить свои мысли через код до других программистов. Код должен быть читаемый подобно книге, сказал Роберт Мартин в своей книге "Чистый код". Многие понимают это прямо и это ошибка. На самом деле это недостижимый идеал. К нему нужно стремиться, но его никогда не достигнуть.

Предлагаю пойти "от противного" и посмотреть для начала как не нужно делать.

## Если бы мы знали что это такое, но мы не знаем что это такое

Почему у разработчиков тяга к бесполезным префиксам и постфиксам, а так же к сильно обобщенным именованиям - не известно.

Давайте рассмотрим добавление префикса/постфикса:

```ts
const userData: User = {
  id: number
  name: string
}
```

Когда я спрашиваю, что означает `Data` на конце, к сожалению в лучшем случае я получают ответ "данные". Если я получаю такой ответ, то задаю вопрос, почему у него на каждой переменной не висит префикс/постфикс `data`. Обычно люди понимают, что это бесполезная штука, мне каждый раз приходится это напоминать, ведь привычка очень долго выкорчёвывается. Тоже самое касается и `info`.

Рассмотрим следующий пример:

```ts
async function foo(value: User) {
  ...
  const object = convert(value)
  ...
  const data = await request(object.query)
  if (data.error) {
    return setError(...)
  }
  ...
  setData(data, object.bar)
}
```

Когда я читаю такой код, я сразу представляю, как такой человек рассказывает про свои действия в таком ключе:

> Вчера я с людьми, сел в транспортное средство и поехал на место. Место было красивое, мы решили удовлетворить естественную потребность. Взяли мебель и пододвинули к мебели, человек принес нам углеводы, жиры и белки. Мы их перенесли из посуды в желудок.

Так же отмечу что я ​Так никто не общается, все говорят "мы с друзьями сели в машину", "решили поесть", "пододвинули стулья и сели за стол", "официант принес нам еду" и т.д. Обычно человек в своей речи использует слова, которые конкретизируют то, что они хотят сказать.

Перепишем функцию избавившись от неверного именования:

```ts
async function foo(user: User) {
  ...
  const { query, bar } = convert(user)
  ...
  const response = await request(query)
  if (response.error) {
    return setError(...)
  }
  ...
  setResponse(response, bar)
}
```

Данный пример содержит условности, но отражает суть. Не нужно обобщать, если вы работаете над конкретными сущностями.

Обобщения нужны в том случае, если вы не знаете с чем конкретным будет работать ваш код. Например есть метод `map` у массива. Мы не знаем какие данные конкретно будет использовать пользователей нашей функции. Давайте ее напишем.

```ts
function map<A, B>(array: A[], ab: (item: A) => B): B[] {
    const result = [] as B[];
    for (let index = 0; index < array.length; index++) {
        result.push(ab(array[index]));
    }

    return result;
}
```

Рассмотрим имена и начнем с аргументов. `array` - это просто массив, мы не знаем, что это за массив, мы можем работать с любым массивом, единственное ограничение и конкретика здесь, то что это должен быть массив. `ab` - это функция которая преобразует `a -> b`. Потому тут не используется слово _"callback"_, которое может означать абсолютно любую функцию. У данной функции есть прямая задача и здесь отражается суть. Можно назвать более полно - `convertAToB`, `transformAToB` и т.д. Я выбрал более короткое имя, оно имеет стандарт в мире функционального программирования. Так как это чистая функция, с именем `map` - которое пришло к нам их этого мира, я решил использовать их стандарты.

Далее имя `result` - оно нам говорит о том, что это результат функции. Так как у нее довольно четкие границы и больше, к тому же данная переменная прибита к `for` - человек сразу понимает, что это и зачем. Так как нет информации, какие элементы будут в результате, так и остается `result`.

Я не сокращаю `index` до `i`. Об этом мы поговорим чуть ниже.

## Скрщния

Одна из самых болезненных вещей при прочтении кода - это сокращения. Часто люди используют сокращения подсмотрев их на `stackoverflow` или в коде других людей. Лично я избегаю сокращений максимально. Это делает код более целостным и заставляет больше думать над именами, которые могут получаться длинными из-за префиксов или постфиксов.

Давайте разберем частые сокращения:

```ts
const handleClick: MouseHandler = (e) => ...
const workWith = (i: number) => ...
const btnText = ...
const idx = ...
const l = array.length
```

Это популярные сокращения. За мою карьеру, даже я сталкивался с тем, что не понимал часть из них по коду. Например я все время думал что `idx` это тоже самое что и `id`, просто человек опечатался. Оказалось, что это `index`. Так же я сталкивался с сокращением `i`, которое уходило за рамки `for` и становилось головной болью, потому что какой-то другой разработчик мог начать использовать функцию так, что передавал не `index`, а какое-то другое число в функцию, которая принимала `i` и это приводило к скрытым ошибкам.

Так же, всякие сокращения по типу `e` внезапно могли начать использоваться не как event, а как `emitter`, или еще какая-то другая сущность. В связи с этим я выработал следующее правило:

> Сокращения из одной буквы - это чистое зло. Сокращения по типу btn чуть меньшее зло.

В итоге, я начал избегать сокращения вовсе. В современном мире, где есть autocomplete, нет нужды экономить символы, пока они бесплатные.

## Функционируем

Как же правильно именовать функции - один из избитых аспектов всея программирования. Основное правило которое применяется, - это начинать с глагола. В целом так оно и должно быть, но не всегда это хорошо читается и может становиться довольно "вербозным", что приводит к ухудшению чтения:

```ts
const checkIsGreaterOrEqual = () => {};

models.user.convertToString();
```

На самом деле в некоторых случаях применимо именование `toString()`, или `isEqual()`. Куда будет приятнее читать вот так:

```ts
const isGreaterOrEqual = (...) => {}

isDisabled={isGreaterOrEqual(foo, bar)}

models.user.toString()
models.user.isValid()
models.user.toPeer()
```

Всегда представляйте себе, как будет использована ваша функция. Таким образом вы всегда сможете найти ответ на вопрос "как же мне назвать функцию".

## Слушаем и обрабатываем

Почему-то у людей при написании обработчиков событий случается буря вариантов.

Например:

```jsx
const onClick = () => {};
const clickHandler = () => {};
const handleClick = () => {};

<div onClick={fn} />;
```

Давайте просто почитаем.

-   `onClick` - на клик `onClick={onClick}` - на клик на клик
-   `clickHandler` - обработчик клика `onClick={clickHandler}` на клик обработчик клика
-   `handleClick` - обработать клик `onClick={handleClick}` на клик обработать клик

После прочтения должно быть понятно, что третий вариант более натуральный, чем остальные, а первый выглядит так, что бытие будет вызывать событие, но никак его не обрабатывать.

На самом деле все довольно просто, если вы создаете функцию, которая будет обрабатывать какое-то событие, то это всегда приставка `handle`:

```jsx
const handleClick = () => {};

<div onClick={handleClick} />;
```

Если вы хотите сообщить что-то, то это приставка on, что символизирует событие. Например **React** использует пропсы с префиксом `on` в стандартных элементах, для работы с событиями. Элементы **React** сами по себе не обрабатывают события, они как бы сообщают через `callback`, что что-то произошло, например клик.

Так же одно событие может порождать другое событие или обработчик порождать какое-либо событие, например возьмем **React** компонент:

```jsx
export type Props = {
  onChange?: (event: KeyboardEvent) => void
}
export const SomeComponent = ({ onChange }: Props) => {
  // ...
  return <input type="text" onKeyDown={onChange} />
}

// ---------------------------------------------------

export type Props = React.PropsWithChildren<{
  id: number
  onSelect?: (id: number) => void
}>

export const SomeComponent = ({ id, children, onSelect}: Props) => {
  const handleClick = () => {
    // ...
    onSelect?.(id)
  }
  return <button type="text" onClick={handleClick}>{children}</button>
}
```

Ссылку на функцию, можно воспринимать как делегирование ответственности за какое-то действие в вашем коде. Вы отдаете обработку на откуп тому, кто будет работать с вашим кодом. Значит вы работаете с `on`, если вы пишете то, что будет обрабатывать какое-то событие, или будет вызываться как `callback` на параметр `on`, то используйте префикс `handle`.
