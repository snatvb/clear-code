# Констатируем

Довольно часто можно увидеть недопонимание как должны выглядеть константы. Конечно для констант используется UPPER_CASE. Однако не все понимают что такое константа.

Я встречал константами и функции, и массивы, и объекты. "Стоп-стоп-стопб а что не так с массивами и объектами?" могут задаться вопросами. И правда, в целом они могут быть константными, тут и начинается разночтение.

Для начала следует понять откуда растут ноги - константы пришли к нам в мир программирования из математики. Это неизменяемое значение, которое вообще никогда не меняется. Конечно мы не математики, и данный параметр может поменяться, но не во время исполнения программы - это очень важно. Константа всегда должна оставаться с одинаковым значением и начала и до конца ее жизни.

И вот что я понял: константами определяются атомарные сущности, которые никогда не меняются и используются как одно целое и не могут производить вычисления. Рассмотрим пример:

```ts
const CONST_1 = () => {}; // incorrect ❌

const CONST_2 = 10; // correct ✅

const ARR_CONST = [1, 2, 3, 4, 5]; // correct ✅

// incorrect: ❌
if (ARR_CONST.includes(2)) {
}

// correct: ✅
if (includes(ARR_CONST, 2)) {
}

const CONFIG = { x: 1, y: 2 }; // correct ✅
calculate(CONFIG.x, event); // incorrect ❌
calculate(CONFIG, event); // correct ✅

// incorrect: ❌
const CFG = {
    FOO: {},
    BAR: 12,
};

// correct: ✅
const cfg = {
    FOO: {},
    BAR: 12,
};
```

Из примеров видно, что константы могут быть использованы только целиком. Они могут быть вложенны друг в друга, потому что это контекст, как es6 модуль `export * as config from './config'` - такие вещи не именуются через UPPER_CASE никогда. В других языках это может быть использоваться с большой буквы.

## На меня накричали!

Некоторые используют в опредении только "эта переменная не меняется в ходе программы, потому она константна". Функция или процедура - это минипрограмма, тогда по этому определению такой код является валидным:

```ts
const NUMERS = [1, 2, 3, 4, 5] as const;
const MY_SUPER_CALCULATION = (ADDITIONAL: number) => {
    const RESULT = NUMBERS.reduce((ACC, N) => ACC + N, 0) + NUMBERS;

    if (RESULT <= 0) {
        return undefined;
    }
    return RESULT;
};
```

`NUMBERS` - никогда не меняется. Значение переменной `MY_SUPER_CALCULATION` тоже - не забываем, это переменная у которой в значении лежит функция. Аргумент `ADDITIONAL` тоже никогда не меняется в ходе программы вычисления(функции). Дальнейшую логику я думаю вы уловили. В данном примере вообще никогда ничего не меняется, потому все подходит под это простое определение. Это крайний случай, но по частям данные проблемы начинают возникать на разных проектах.
